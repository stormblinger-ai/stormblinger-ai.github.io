[{"categories":null,"content":"人工智能发展热点 **1.机器学习：**让计算机通过数据学习并不断优化自身算法的能力，就像是孩子从不断接触新事物中学习成长。 **2.深度学习：**一种机器学习方法，通过多层神经网络模拟人类大脑的工作方式，可以用于图像识别、自然语言处理等领域。 **3.神经网络：**模仿生物神经元连接方式的计算模型，用于实现机器学习和深度学习。 **4.自然语言处理：**让计算机理解和处理人类自然语言的技术，可以用于机器翻译、语音识别、文本分类等应用。 **5.人工智能：**让计算机模拟人类智能的能力，可以包括机器学习、自然语言处理、图像处理等技术。 **6.机器人：**一种能够执行特定任务并与环境交互的自主体系，可以是物理机器人或虚拟机器人。 **7.智能家居：**通过人工智能技术，让家居设备自动化、智能化，实现更加便捷、舒适的生活体验。 **8.无人驾驶：**使用自动驾驶技术，让车辆自主行驶，无需人类干预。 **9.人脸识别：**通过图像处理和机器学习技术，让计算机能够识别出人脸，并进行人脸验证、人脸比对等操作。 **10.语音助手：**使用自然语言处理和人工智能技术，让计算机能够理解人类语言并执行特定指令，如Siri、Alexa等。 **11.聊天机器人：**通过自然语言处理和人工智能技术，让计算机能够与人类进行自然对话，如微软小冰、小度等。 **12.区块链：**一种去中心化的数据库技术，可以用于保护数字资产、实现数字身份认证等领域。 **13.人工智能芯片：**一种专门用于加速人工智能计算的芯片，可以在训练和推理阶段提升计算效率。 **14.量子计算机：**使用量子比特进行计算的计算机，能够在特定场景下实现比传统计算机更快的计算。 **15.虚拟现实：**使用计算机技术创造一个虚拟的三维环境，并通过头戴式显示器等设备让用户身临其境，如Oculus Rift等VR设备。 **16.深度强化学习：**一种机器学习方法，结合强化学习和深度学习技术，让计算机通过试错学习，优化决策模型。 **17.数据挖掘：**通过分析大量数据，发现其中的模式和规律，并从中提取有用信息的过程。 **18.面部表情识别：**通过计算机视觉和机器学习技术，让计算机能够识别人类面部表情，并了解人类情绪状态。 **19.机器翻译：**通过自然语言处理和机器学习技术，让计算机能够将一种自然语言翻译成另一种自然语言。 **20.图像分割：**通过计算机视觉技术，将一张图像分成多个部分，每个部分表示一种不同的物体或区域。 **21.机器人视觉：**让机器人通过视觉传感器获取周围环境信息，并对其进行理解和处理的技术。 **22.机器学习算法：**一组用于机器学习的计算模型和算法，包括决策树、支持向量机、神经网络等等。 **23.语音识别：**让计算机通过声音传感器获取人类语音信息，并将其转换为文字或特定指令的技术。 **24.自主驾驶：**使用自动驾驶技术，让车辆自主感知周围环境并做出决策，实现无需人类干预的行驶。 **25.数据分析：**通过分析大量数据，获取其中的信息和洞察，并做出相应的决策的过程。 **26.人机交互：**通过人工智能技术，让计算机与人类进行自然、智能的交互，如手势识别、语音识别等技术。 **27.逆向推理：**通过已有结论，逆向推理出需要满足的前提条件和假设的技术，用于知识推理和智能决策。 **28.机器人控制：**通过计算机技术，控制机器人运动和行为的过程。 **29.超级计算机：**具有超强计算能力和存储能力的计算机系统，可用于科学研究、气象预测、金融交易等领域。 **30.云计算：**一种基于互联网的计算方式，将计算机处理能力、存储资源、应用程序等服务，通过互联网提供给用户使用。 **31.语音合成：**将计算机生成的文字信息转换为声音信息，实现自然语言的生成的技术。 **32.大数据：**指数据量非常庞大、种类繁多的数据集合，需要特殊的处理和管理方式。 **33.强化学习：**一种机器学习方法，让计算机通过不断试错和学习，逐渐优化决策模型。 **34.模式识别：**通过机器学习技术，让计算机能够识别和分类不同的模式，如声音、图像等。 **35.机器视觉：**通过计算机视觉技术，让计算机能够感知和理解周围的视觉信息，如图像、视频等。 **36.深度学习框架：**一种用于实现深度学习算法的软件架构，如TensorFlow、PyTorch等。 **37.遗传算法：**通过模拟自然进化过程，优化问题的解决方案的算法。 **38.分布式计算：**将计算任务分配给多台计算机进行处理，提高计算效率和处理能力的计算方式。 **39.机器学习平台：**提供机器学习算法和模型的平台，如Google Cloud AI、Amazon SageMaker等。 **40.数据库管理系统：**管理和处理数据库的软件系统，包括MySQL、Oracle等。 **41.人机协作：**通过人工智能技术，实现人类与机器之间的紧密合作，如工业机器人、智能家居等。 **42.脑机接口：**一种人机交互技术，通过直接读取人类的脑电信号，实现人类与计算机的交互和控制。 **43.人工智能作曲：**通过机器学习和生成模型，让计算机能够自动创作音乐，并且具有一定的艺术性和创造性。 **44.自适应学习：**一种机器学习技术，让计算机能够自动调整和优化学习策略，以适应不同的数据和任务。 **45.面部识别：**一种基于人脸特征的识别技术，如用于解锁手机、刷脸支付等。 **46.语音识别笔记本：**一种具备语音识别功能的笔记本电脑，能够通过语音指令完成各种操作，如苹果的Siri、微软的Cortana等。 **47.机器翻译器：**一种可以实时翻译多种语言的机器翻译设备，如谷歌的Pixel Buds等。 **48.自主学习：**让计算机能够自主获取和处理数据，自我学习和优化算法的能力。 **49.智能客服：**通过自然语言处理和机器学习技术，实现智能化的客户服务，如淘宝客服、京东客服等。 **50.机器人助手：**通过人工智能技术，让机器人能够为人类提供各种帮助，如吸尘机器人、智能家居机器人等。 **51.人工智能教育：**通过人工智能技术，提供个性化、定制化的教育服务，如智能辅导、智能教材等。 **52.人工智能医疗：**通过人工智能技术，提供更精准、更高效的医疗服务，如医学影像诊断、智能辅助诊疗等。 **53.智能制造：**通过人工智能技术，实现智能化、自动化的制造过程，如智能工厂、智能物流等。 **54.人工智能安防：**通过人工智能技术，实现更智能、更高效的安防监控，如智能监控摄像头、智能门禁系统等。 **55.机器人教育：**通过机器人教学平台，让学生了解人工智能、机器人等新兴科技，提高STEM素养和创新能力。 **56.人工智能聊天机器人：**一种具备自然语言处理和智能对话能力的聊天机器人，如微软的小冰、阿里的天猫精灵等。 **57.人工智能音箱：**一种具备语音识别、自然语言处理和智能家居控制能力的音箱，如Amazon Echo、Google Home等。 **58.机器人游戏：**一种利用机器人技术，实现机器人与人类的互动和协作的游戏，如RoboCup等。 **59.图像处理：**一种利用计算机技术对图像进行分析、处理和识别的技术，如人脸识别、图像分类等。 **60.推荐系统：**一种利用计算机技术对用户行为和兴趣进行分析和挖掘，从而向用户推荐个性化内容和服务的系统，如电商平台、社交网络等。 **61.知识图谱：**一种利用计算机技术对知识进行结构化表示、组织和应用的技术，如百度百科、谷歌知识图谱等。 **62.语义分析：**一种利用计算机技术对语言和文本进行理解和分析，从而推断出语义和意图的技术，如智能客服、智能搜索等。 **63.量子计算：**一种基于量子力学原理的计算技术，具有高效性和并行性优势，被认为是未来计算的重要方向之一。 **64.智能交通：**通过智能技术和物联网技术，实现道路交通系统的智能化、高效化和安全化，如智能交通信号灯、智能停车系统等。 **65.智能物流：**通过物联网技术和人工智能技术，实现物流过程的智能化、自动化和优化化，如智能物流调度、智能物流仓库等。 **66.自动驾驶：**通过人工智能技术和传感器技术，实现车辆自主导航、智能避障等功能，实现无人驾驶的汽车，被认为是未来交通的重要方向之一。 **67.机器人技术：**利用计算机技术、机械技术和传感器技术等对机器人进行设计、制造和控制，实现机器人智能化、自主化和协作化，如工业机器人、服务机器人等。 **68.智慧城市：**通过智能技术和物联网技术，实现城市管理和生活服务的智能化、高效化和可持续化，如智能公共交通、智能环保等。 **69.增强现实：**通过计算机技术和传感器技术，在真实世界的基础上叠加虚拟信息，实现现实与虚拟的混合，如Pokemon Go等。 **70.图像识别：**一种利用计算机技术对图像进行分析和识别的技术，如人脸识别、图像搜索等。 **71.聊天机器人：**一种利用自然语言处理和人工智能技术，实现与用户进行对话和交互的智能机器人，如微软小冰、阿里小蜜等。 **72.语音唤醒：**一种利用语音识别和人工智能技术，实现设备被唤醒和操作的技术，如“小爱同学”、“Siri”等。 **73.数据仓库：**一种利用计算机技术对大规模数据进行存储和管理的技术，为企业决策提供数据支持，如数据仓库、数据湖等。 ","date":"2023-08-28","objectID":"/ai%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/:1:0","tags":null,"title":"AI人工智能","uri":"/ai%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"categories":null,"content":"AIGC是指“AI Generative Content”，即人工智能生成内容。主要指自动生成各种类型的文本、图像、音频、视频等内容。这种技术可以应用于多个领域，包括但不限于媒体、教育、娱乐、营销和科学研究领域，为用户提供高效、高质量和具有个性化的内容服务。 AIGC主要有以下四大技术场景，请往下看： **文本生成：**使用AIGC技术，可快速生成文章、新闻报道、博客、广告文案和创意写作等内容，为撰稿人、编辑和营销人员提供高效的创作方式，帮助他们快速生成初稿，并提升工作效率。 **图片生成：**AIGC技术可广泛应用于图像和艺术作品的自动生成。通过深度学习算法，该技术能够根据用户输入的关键词和样式指南，自动生成具有艺术美感的图像和创意作品。这种自动化生成技术可以提高设计师和艺术家的生产力，并为他们带来更多创作灵感。 **视频生成：**AIGC技术是一种高效的视频内容生成工具，其应用范围包括短视频、动画、电影预告等。该技术可以通过自动化处理来加速视频创作的过程，同时保持较高的创作质量。此外，AIGC技术还支持自动生成字幕和视频描述，以及自动化的视频剪辑和渲染，大大提高了视频制作的效率和质量。这种视频生成技术可以帮助创作者更加专注于创意和艺术性，从而实现更好的视觉传达效果。 **音频生成：**AIGC技术可用于生成多种音频内容，例如手机导航语音、文案朗读、虚拟人语音等。通过自动化生成技术，AIGC技术可以提供高效的音频制作方式，为用户节省时间和人力成本。同时，AIGC技术还支持自定义音频风格和音色，以适应不同的场景和用户需求。这种音频生成技术将在未来的智能音频系统和虚拟人机器人中得到广泛应用。 ","date":"2023-07-20","objectID":"/aigc%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/:0:0","tags":null,"title":"AIGC应用场景","uri":"/aigc%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"},{"categories":null,"content":"1，微服务架构区别于传统的单体软件架构，是一种为了适应当前互联网后台服务的「三高需求：高并发、高性能、高可用」而产生的的软件架构。 2，后端架构演进 单体架构 应用和数据库分离-垂直架构 数据库主从架构 分布式应用框架 分布式缓存架构 数据库分库分表 微服务架构 K8S容器化，云原生架构 3，SOA架构方法可以简单的总结为找到服务，组合和组装服务。 即将传统的企业IT系统竖井式的纵向建设方式转变为横向分层的建设模式。在电信里面有个eTom模型总结了横向分为 资源-服务-应用 三个层面，这个相当经典。对应到SOA里面完全适用。即最底层的资源是我们识别的底层遗留系统和组件，而服务层是遗留系统暴露的可以复用的API接口，到了应用层则是对已有服务接口的组装和编排形成新的业务。 即新业务的构建不再是纵向新构建一个系统，而是通过已有的服务能力进行上层组装。在整个横向分层架构里面，服务层相当重要，起到了了底层资源和上层新应用间很好的解耦作用。 4，微服务的核心很简单就是大拆小，传统的单体应用要拆分为更加细的业务组件模块，从这个意义上来说微服务本身并不需要体现我前面谈到的SOA横向分层和复用的思想。对于微服务简单来说核心就是： 一个单体变多个微服务模块，而且从数据库到逻辑层到前端完全独立 微服务模块间通过Http Rest接口高效集成协同 各个微服务完全独立部署，扩展的时候数据库，集群都单独扩展 5，对于Cloud Native翻译为云原生，是Matt Stine提出的一个概念，它是一个思想的集合，包括DevOps、持续交付（Continuous Delivery）、微服务（MicroServices）、敏捷基础设施（Agile Infrastructure）、康威定律（Conways Law）等，以及根据商业能力对公司进行重组。Cloud Native既包含技术（微服务，敏捷基础设施），也包含管理（DevOps，持续交付，康威定律，重组等）。 因此云原生是一系列Cloud技术、企业管理方法的集合。 云原生应用程序开发通常包括DevOps，敏捷方法，微服务，云平台，Kubernetes和Docker等容器，以及持续交付，简而言之，每种新的和现代的应用程序部署方法。 CNCF给出了云原生应用的三大特征： 容器化封装：以容器为基础，提高整体开发水平，形成代码和组件重用。 动态管理：通过集中式的编排调度系统来动态的管理和调度。 面向微服务：明确服务间的依赖，互相解耦。 实际上我们看到对于完整的DevOps是包括了持续交付方面的内容的。因此对于云原生的概念完全和我前面经常谈到的微服务，容器化PaaS和DevOps相吻合。 即云原生 = 微服务+ DevOps + 容器化PaaS 云原生本身包括了云原生平台和云原生应用，而平台则是指容器PaaS平台和DevOps能力支撑平台，而云原生应用可以理解为基于微服务思想和开发框架开发的微服务应用。 6，概念知识 1.微服务与云原生的本质是系统集成 2.系统集成的本质是进程通信 3.进程管理的方向是虚拟化技术 4.虚拟化的进化到了容器标准 5.容器化交付是CI和CD的基础 6.CI和CD是PasS平台服务的对象 7.Servless是PasS的极端形式 8.云原生代表技术包括 容器 服务网格 微服务 不可变基础设施 声明式API 9.不可变基础设施——凤凰服务器——轻量化容器化实现凤凰服务器思想` ","date":"2023-05-08","objectID":"/%E4%BB%8Esoa%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%B0%E4%BA%91%E5%8E%9F%E7%94%9F/:0:0","tags":null,"title":"从SOA微服务到云原生","uri":"/%E4%BB%8Esoa%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%B0%E4%BA%91%E5%8E%9F%E7%94%9F/"},{"categories":null,"content":"1，web3.0 Web 3.0是互联网的潜在下一阶段，一个运行在“区块链”技术之上的“去中心化”的互联网。Web 3.0的基础是区块链技术，而它又是元宇宙概念的底层架构和逻辑基础。Web 3.0最大的一个特点是去中心化。 Web 3.0的应用范围很广，包括但不限于： 去中心化身份认证 去中心化数据存储 去中心化金融 去中心化社交网络 ","date":"2022-10-28","objectID":"/%E4%BB%8Eweb3%E5%88%B0%E5%85%83%E5%AE%87%E5%AE%99/:1:0","tags":null,"title":"从web3到元宇宙","uri":"/%E4%BB%8Eweb3%E5%88%B0%E5%85%83%E5%AE%87%E5%AE%99/"},{"categories":null,"content":"2，元宇宙 元宇宙是一个3D的虚拟环境，可以利用VR、AR、手机、电脑等等来进入这个虚拟世界，让我们置身于其中的网络，用虚拟替身(Avatar)来体验元宇宙。而元宇宙可以说是WEB 3.0的一个大的应用场景 元宇宙的应用方向和产品有很多，以下是一些常见的应用方向和产品： 游戏：虚拟现实游戏、角色扮演游戏等。 社交：社交网络、虚拟社区等。 教育：在线教育、虚拟教室等。 艺术：虚拟艺术展、数字艺术品等。 商业：虚拟商店、数字货币等。 ","date":"2022-10-28","objectID":"/%E4%BB%8Eweb3%E5%88%B0%E5%85%83%E5%AE%87%E5%AE%99/:2:0","tags":null,"title":"从web3到元宇宙","uri":"/%E4%BB%8Eweb3%E5%88%B0%E5%85%83%E5%AE%87%E5%AE%99/"},{"categories":null,"content":"Django的创建与项目结构 虚拟环境+项目+APP创建 pycharm创建纯净的Python项目+虚拟环境 安装Django和相关库API 创建APP 运行 ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:0:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"1，虚拟环境+项目+APP创建（使用pycharm2022.3创建） 虚拟环境创建选择有多种，virtualenv，pipenv，conda，或者选用PDM相关的本地环境都可以，我这里主要选用virtualenv，后期项目做大，迭代版本或者多版本共存，出现三方库，包依赖管理问题时，建议conda或PDM/poetry pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:1:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"2，Django安装和创建APP 1，安装Django3.2 pip install django==3.2 2,安装djangorestframework 安装DRF3.x版本，包名为djangorestframework，2.x包名为django-restframework # 注册用 'rest_framework', 3，在当前目录中创建项目,用. Django-admin startproject pj . #4,创建文件夹apps/news,创建APP，一定要是目录！！！不然不识别 python manage.py startapp apps/news ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:2:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"3，目录结构调整 常量 ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:3:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"4，settings目录 ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:4:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"5, pycharm运行配置 Django的项目配置 ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:5:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"1、常见APP注册， INSTALLED_APPS = [ # 原生 'django.contrib.admin', 'django.contrib.auth', # 三方库 'rest_framework', # 自己编写 'apps.news', 这里注意如果想直接写APP名字，需要把文件夹路径加到BASE_DIR中 # 新增一个系统导包路径，可见上3，容易出现找不到APP问题 # import sys # sys.path.insert(0,os.path.join(BASE_DIR,\"apps\")) ] ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:6:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"2、数据库配置 1、Django配置MySQL -pip install pymysql 2,最开始创建的项目的init文件写， import pymysql pymysql.install_as_Mysqldb() 3,连接属性 ‘default’：{ 'ENGINGE': 'django.db.backends.mysql' # 'ENGINE': 'dj_db_conn_pool.backends.mysql',连接池 'NMAE': 数据库名字 'USER': 'PASSWORD': 'HOST': IP地址 'PORT': # 设置连接池，看情况选择 pip install django-db-connection-pool 'POOL_OPTIONS': { 'POOL_SIZE': 10, # 最小 'MAX_OVERFLOW': 10, # 在最小的基础上，还可以增加10个，即：最大20个。 'RECYCLE': 24 * 60 * 60, # 连接可以被重复用多久，超过会重新创建，-1表示永久。 'TIMEOUT':30, # 池中没有连接最多等待的时间。 } } 2、Django配置Redis -1、安装第三方库，Redis常用命令，都以函数的形式呈现，里面有很多参数需要自己选择填 pip install django-redis -2、settings文件配置 # 配置redis缓存 CACHES = { 'default': { 'BACKEND': 'django_redis.cache.RedisCache', # 缓存后端 Redis # 连接Redis数据库(服务器地址) # 一主带多从(可以配置多个Redis，写走第一台，读走其他的机器) 'LOCATION': [ 'redis://127.0.0.1:6379/0', ], 'KEY_PREFIX': 'lybbn', # 项目名当做文件前缀 'OPTIONS': { 'CLIENT_CLASS': 'django_redis.client.DefaultClient', # 连接选项(默认，不改) 'CONNECTION_POOL_KWARGS': { 'max_connections': 512, # 连接池的连接(最大连接) }, } }, 'session': { #缓存session }, 'verify_codes': { #缓存短信验证码 }, \"carts\": { #登陆过的用户购物车的存储 \"OPTIONS\": { \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\", 'CONNECTION_POOL_KWARGS': {'decode_responses': True}, # 添加这一行,防止取出的值带有b'' bytes }, }, \"authapi\": { # 接口安全校验（验证接口重复第二次访问会拒绝） }, \"singletoken\": { # jwt单用户登录（确保一个账户只有一个地点登录，后一个会顶掉前一个） 'OPTIONS': { 'CLIENT_CLASS': 'django_redis.client.DefaultClient', # 连接选项(默认，不改) 'CONNECTION_POOL_KWARGS': {'decode_responses': True}, # 添加这一行,防止取出的值带有b'' bytes } }, } REDIS_TIMEOUT = 7 * 24 * 60 * 60 CUBES_REDIS_TIMEOUT = 60 * 60 NEVER_REDIS_TIMEOUT = 365 * 24 * 60 * 60 CHANNEL_LAYERS = { 'default': { \"BACKEND\": \"channels.layers.InMemoryChannelLayer\" # 默认用内存 }, } # # 配置channels_redis，windows redis运行后报错：aioredis.errors.ReplyError: ERR unknown command 'BZPOPMIN'，请注释以下配置或升级redis到5.0及以上 # CHANNEL_LAYERS = { # 'default': { # 'BACKEND': 'channels_redis.core.RedisChannelLayer', # 'CONFIG': { # \"hosts\": [\"redis://localhost:6379/5\"], # }, # }, # } # session使用的存储方式 SESSION_ENGINE = \"django.contrib.sessions.backends.cache\" # 指明使用哪一个库保存session数据 SESSION_CACHE_ALIAS = \"session\" -3、使用范例 from django_redis import get_redis_connection // 获取链接redis数据库 redis_conn = get_redis_connection(\"default\") -4、使用事务，创建管道对象用来装载事务操作的命令 事务只针对写操作，即增删改，无法控制读操作 #创建管道 pipe = redis_conn.pipeline() #开启事务 pipe.multi() #事务操作命令 pipe.hset(\"cart_%s\" % user_id, course_id, expire) pipe.sadd(\"selected_%s\" % user_id, course_id) #执行事务 pipe.execute() #日志异常处理配置，为了保证Redis的跟进和系统同步 ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:7:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"3、静态文件和上传文件配置 1、#需要安装图片文件处理模块 pip install pillow 2、#配置settings.py文件 # 访问静态文件的url地址前缀 STATIC_URL = '/static/' # 设置django的静态文件目录 STATICFILES_DIRS = [ os.path.join(BASE_DIR,\"static\") ] 3、# 项目中存储上传文件的根目录[暂时配置]，注意，uploads目录需要手动创建否则上传文件时报错 MEDIA_ROOT=os.path.join(BASE_DIR,\"uploads\") # 访问上传文件的url地址前缀 MEDIA_URL =\"/media/\" 4、总路由urls.py #from django.urls import re_path from django.conf import settings from django.views.static import serve urlpatterns = [ ... re_path(r'media/(?P\u003cpath\u003e.*)', serve, {\"document_root\": settings.MEDIA_ROOT}), ] ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:8:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"4、日志配置 ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:9:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"5、文档配置 ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:10:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"6、异常配置 ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:11:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"7、任务队列 异步和定时任务：celery+rabbitmq+Redis,可以直接嵌入项目中，也可以做可插拔的，可插拔如下： # 安装rabbitmq # 1，安装celery pip install -U celery # 2，创建celery框架包，在根目录中 -mycelery # 3，包中创建配置文件和入口文件 -mycelery -config.py 配置 -main.py 入口 -init.py # 4，为任务创建包，必须创建一个tasks.py作为目标文件 -mycelery -sms -tasks.py ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:12:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"main.py和config.py # main.py，运行过程：导包-实例-加载配置-任务对象-启动 from celery import Celery # 导包 # 把celery和django进行组合，识别和加载django的配置文件 import os os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'api.settings.dev') import django django.setup() app = Celery('flower') # 创建celery主程序对象实例 app.config_from_object('mycelery.config') #多种方式，文件，对象和json，这里用config文件作为加载配置项 app.autodiscpver_tasks(['mycelery.sms',]) # 目标对象 # 启动，在终端中启动,windows命令要加其他的 celery -A mycelerymain worker --loglevel=info # config.py broker_url = 'amqp://fc:123@127.0.0.1:5672//fc_Vhost1' # 消费队列 result_backend = 'redis://127.0.0.1:6379/14' # 结果队列 ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:12:1","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"tasks.py # sms.tasks.py # celery的任务必须写在tasks.py的文件中，别的文件名称不识别!!! from mycelery.main import app @app.task # name表示设置任务的名称，如果不填写，则默认使用函数名做为任务名 def send_sms(): print(\"发送短信!!!\") @app.task(name='sms') def send_sms2(): print(\"发送短信任务2!!!\") # 调用 from mycelery.sms.tasks import send_sms send_sms.delay() 添加日志 # 日志是Python提供的 import logging log = logging.getLogger(\"django\") ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:12:2","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"8、定时任务 用celery或者自带Django-crontab Django项目API接口创建 ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:13:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"1、创建APP python manage.py startapp name或者 django-admin startapp name apps/name ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:14:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"2、APP注册 settings.py文件 INSTALLAPP = [ 'name' 或者 'apps/name' ] ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:15:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"3、模型models创建/迁移 models.py -导Django自带模型包 from django.db import models -声明模型表数据类 class Flower(models.model) # 命名用单词 -字段名 = 字段类型（字段约束） name = models.charField(max_length= , verbose_name=) -外键/表关系 name = models.ForeignKey(to=\"Dictionary\", db_constraint=False, on_delete=models.PROTECT, blank=True, null=True,verbose_name=\"父级\", help_text=\"父级\") -自定义函数 def __str__(): return self.title -class meta、表信息声明 class_Meta: verbose_name = 迁移 python manage.py makemigrations python manage.py migrate 常用选项 -数值型 AutoField 主键自增 int(11) IntegerField 有符号整数 int(11) PostiveIntegerField 正整数 init(11) SmallInteterField 整数 smallint DecimalField 定点数 decimal max_digits：总位数，decimal_places：小数位 BooleanField 布尔 tinyint(1) -字符型 CharField varchar max_length：最大长度 TextField 大文本longtext URLField 字符串 ********* UUIDField char(32) EmailField email FileField 文件 ImageField 图片 -日期类型 字段 说明 DateField date DateTimeField datetime TimeField time -关系类型 ForeignKey 多对一 OneToOneField 一对一 ManyToManyField 多对多 through on_delete CASCADE:这就是默认的选项，级联删除，你无需显性指定它。 models.DO_NOTHING PROTECT: 保护模式，如果采用该选项，删除的时候，会抛出ProtectedError错误。 SET_NULL: 置空模式，删除的时候，外键字段被设置为空，前提就是blank=True, null=True,定义该字段的时候，允许为空。 SET_DEFAULT: 置默认值，删除的时候，外键字段设置为默认值，所以定义外键的时候注意加上一个默认值。 SET(): 自定义一个值，该值当然只能是对应的实体了 related_name to: 利用orm自动创建第三张关系表 db_constraint 2 字段约束 2.1 表内约束 db_index 建立索引 db_column 字段名 primary_key 主键 null 表内为空 unique 唯一 unique_for_date 日期唯一 unique_for_year 年份唯一 unique_for_month 月份唯一 default 默认值 required 必填项 2.2 业务层约束 blank 提交可以为空 chioces 选项 editable 是否可编辑 verbose_name 业务层展示名字 error_message 验证失败的异常提示 validators 自定义检验 help_text 字段提示语 ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:16:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"classmeta -classmeta: 使用内部meta类 来给模型赋予元数据，所谓模型的元数据即“所有不是字段的东西”，比如培训选项（ordering）,数据库表名（db_table），或是阅读友好的单复数名（verbose_name和verbose_name_plural）。这些都不是必须的，并且在模型当中添加meta类也完全是可选的 -自定义方法： 在模型中添加自定义方法会给你的对象提供自定义的“行级”操作能力。与之对应的是类manager的方法意在提供“表级”的操作，模型方法应该在某个对象实例上生效。这是一个将相关逻辑代码放在一个地方的技巧--模型。 *__ str__():返回值展示了一个对象。Python和Django在要将模型实例展示为纯文本时调用。最有可能的应用场景是交互式控制台或后台，你将会经常定义此方法；默认提供的不是很好用 *get_absolute_url():该方法告诉Django如何甲酸一个对象的URL，Django在后台接口使用此方法，或任意时间它需要计算一个对象的URL。任何需要一个唯一URL的对象需要定义此方法 ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:16:1","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"4、后台admin集成 当前APP/apps.py admin.site.register(模型名) ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:17:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"5、序列化器serializer编写 serializers.py -导DRF序列化器包 from rest_framework import serializers -导入模型表 from .models import name -声明序列化器类名（继承） class nameModelSerializer(serializers.ModelSerializer): \"\"\" name序列化器 \"\"\" class Meta: model = name fields = [\"id\",\"name\"] 常用选项 ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:18:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"6、视图view view.py、！！！使用切片可以不激活queryset的缓存机制，一旦使用迭代循环，则会启用queryset缓存！！！或者使用models.objects.func()，而不是使用queryset -导DRF视图包 from rest_framework.generics import ListAPIView -导入模型类 from .models import CourseCategory -导入序列化器类 from .serializers import CourseCategoryModelSerializer -声明视图类名（继承） class CourseListAPIView(ListAPIView): -queryset对象和条件 queryset = Course.objects.filter(is_show=True, is_deleted=False).order_by(\"orders\",\"-id\") -序列化器 serializer_class = CourseModelSerializer -附加条件 filter_backends = [DjangoFilterBackend, OrderingFilter] filter_fields = ['course_category'] ordering_fields = ('id', 'students', 'price') pagination_class = CoursePageNumberPagination 常用选项 -视图包GenericAPIView ## GenericAPIView的视图子类 （1）CreateAPIView 提供了post方法，内部调用了create方法 继承自： GenericAPIView、CreateModelMixin #### （2）ListAPIView 提供了get方法，内部调用了list方法 继承自：GenericAPIView、ListModelMixin #### （3）RetrieveAPIView 提供了get方法，内部调用了retrieve方法 继承自: GenericAPIView、RetrieveModelMixin #### （4）DestoryAPIView 提供了delete方法，内部调用了destory方法 继承自：GenericAPIView、DestoryModelMixin #### （5）UpdateAPIView 提供了put和patch方法，内部调用了update和partial_update方法 继承自：GenericAPIView、UpdateModelMixin #### （6）ListCreateAPIView 提供了get和post方法，内部调用了list和create方法 继承自：GenericAPIView、ListModelMixin、CreateModelMixin #### （7）RetrieveUpdateAPIView 提供 get、put、patch方法 继承自： GenericAPIView、RetrieveModelMixin、UpdateModelMixin #### （8）RetrieveDestoryAPIView 提供 get、delete方法 继承自：GenericAPIView、RetrieveModelMixin、DestoryModelMixin #### （9）RetrieveUpdateDestoryAPIView 提供 get、put、patch、delete方法 继承自：GenericAPIView、RetrieveModelMixin、UpdateModelMixin、DestoryModelMixin -queryset条件 3.1 链式调用接口 all() 查询所有 filter(条件) 按条件查询 exclude(条件) 查询不满足条件的 reverse() 把QuerySet结果倒叙排列 distinct() 去重 none 返回空的QuerySet 3.2 非链式调用接口 get 返回满足条件的唯一结果，多或没有满足都报异常 create 写入数据库并创建对象 get_or_create 没有get到就create update_or_create 没有update到就create count QuerySet的结果数量 latest 最新的一条记录 必填字段：field_name，按字段排序的最新一条 earliest 最早的一条记录 必填字段：field_name，按字段排序的最早一条 first QuerySet第一条 last QeurySet最后一条 exists 是否存在 bulk_create 多条创建，返回list in_bulk 批量查询 update 更新 delete 删除 values 返回字段值 values_list 返回tuple的QuerySet 比如： # 多条创建 user_s = User.objects.bulk_create([User(name='name%s' % i) for i in range(10)]) # User中最新的一条 user_latest = User.objects.latest(field_name='id') 3.3 进阶接口 defer 需要的字段延时加载 only 只加载指定字段 select_related 多对一查询，只能从多中查一，不能一中查多 prefetch_related 多对多关联查询 比如： 博客懒加载内容 # 懒加载name topic_s = Topic.objects.all().defer('name') # 多对一查询关联sender，避免N+1次查询 topic_s = Topic.objects.all().select_related('sender') # 多对多关联collectors，避免N+1次查询 topic_s = Topic.objects.all().prefetch_related('collectors') only案例同defer 3.4 字段查询 contains 包含 icontains 包含、忽略大小写 exact 相等 iexact 相等、忽略大小写 in 范围查询 gt 大于 gte 大于等于 lt 小于 lte 小于等于 startwith 开头 istartwith 开头、忽略大小 endswith 结尾 iendswith 结尾、忽略大小 range 范围查询 3.5 进阶查询 F 表内字段比较 Q 逻辑比较 Count 个数 Sum 求和 比如： User.objects.get(id=Count('user') User.objects.get(id=Sum('money')) ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:19:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"orm对应的MySQL操作 ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:19:1","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"django-redis对应Redis中操作 # string # 1,redis连接操作,用的是Redis生core接口 redis_conn = get_redis_connection('default') redis_conn.set(name, value, ex=秒, px=毫秒, nx=键不存在, xx=键存在, keepttl=False, get=False, exat=None, pxat=None) get() mset mget setex setnx # 2,缓存操作，用的是django-redis提供的RedisCache接口，其继承于Django的basecache cache.set(k,json.dumps(value))/pickle json.loads(get())/pickle get() has_key get_or_set set_many({}) get_many([]) set incr_version add get delete delete_pattern delete_many clear incr decr has_key keys iter_keys ttl pttl persist expire pexpire_at lock close touch # list # hash # set # zset ","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:19:2","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"7、路由urls、子路由——\u003e总路由 当前app/urls.py -导Django自带URL包中的path和re_path from django.urls import path,re_path -导入视图类 from . import views -urlpattrns=[]列表 urlpatterns = [ path(r\"category/\", views.CourseCategoryListAPIView.as_view() ), path(r\"\", views.CourseListAPIView.as_view() ), re_path(r\"(?P\u003cpk\u003e\\d+)/\", views.CourseRetrieveAPIView.as_view()), path(r\"chapter/\", views.CourseChapterListAPIView.as_view()), ] 当前项目/urls.py -按需添加内容 urlpatterns = [ re_path(r'media/(?P\u003cpath\u003e.*)', serve, {\"document_root\": settings.MEDIA_ROOT}), path(r'^ckeditor/', include('ckeditor_uploader.urls')), path('', include('home.urls')), path('user/', include('user.urls')), ] 常用选项 Django三方组件库和插件 Django-allauth - 用户注册登录管理 官网地址：https://django-allauth.readthedocs.io/en/latest/ Django-haystack - 全文检索引擎 官网地址：https://django-haystack.readthedocs.io/en/master/ 全文检索不同于标题的简单匹配，是一件技术难度比较高的活。当文章很长时，很难找到精确的匹配，同时搜索全文需要消耗大量的计算资源。有了haystack，在django中直接添加搜索功能，像搜索标题一样搜索全文，而无需关注索引建立、搜索解析等技术问题。haystack支持多种搜索引擎，不仅仅是whoosh，使用solr、elasticsearch等搜索，也可通过haystack，而且直接切换引擎即可，甚至无需修改搜索代码。 Django-ckeditor - 富文本编辑器 官网地址：https://django-ckeditor.readthedocs.io/en/latest/ django没有提供官方的富文本编辑器，而ckeditor恰好是内容型网站后台管理中不可或缺的控件。ckeditor是一款基于javascript，使用非常广泛的开源网页编辑器。它允许用户直接编写图文，插入列表和表格，并支持文本和HTML格式代码输入。 Django-imagekit - 自动化处理图像 官网地址：https://django-imagekit.readthedocs.io/en/latest/ 现代网站开发一般免不了处理一些图片，例如头像、用户上传的图片等内容。django-imagekit 帮配合 django 的 model 模块自动完成图片的裁剪、压缩、生成缩略图、加水印等一系列图片相关的操作。 Django-debug-toolbar - django项目调试利器 官网地址：https://django-debug-toolbar.readthedocs.io/en/latest/ 该工具给django web开发提供了强大的调试功能，包括查看执行的sql语句，db查询次数，request，headers，调试概览等。通过安装插件Pympler，还可以了解内存使用情况。 Django-celery - 执行异步任务或定时任务的最佳选择 官网地址：http://docs.celeryproject.org/en/latest/django/index.html https://docs.celeryproject.org/en/stable/django/first-steps-with-django.html Celery 是一款非常简单、灵活、可靠的分布式系统，可用于处理大量消息，并且提供了一整套操作此系统的一系列工具。另外，Celery 是一款消息队列工具，可用于处理实时数据以及任务调度。官网给出了 Celery 如下四个特点： • 简单：开箱机用，维护简单，不需要使用配置文件； • 高可靠性：如果连接丢失或者出现故障，客户端进程会自动重试。一些 broker 会以主/主或者主/备的方式维持系统的高可靠性； • 快速：单个 Celery 进程每分钟内可以处理数百万个任务，往返的延迟在毫秒级别(使用RabbitMQ 做中间件，再加上一些优化的设置)； • 灵活：几乎 Celery 的每个部分都可以自行扩展，如使用自定义池、序列化器，压缩方案、日志记录，调度程序，消费者，生产者，代理传输等等。 注意到基于 Django 框架构建的 Web 系统实际上是一个同步服务。这意味着当客户端发起一个请求时，后端只有在视图函数处理完后才会返回结果。如果这个请求背后要做的工作比较耗时，或者因为某种原因导致非常耗时，那么此时客户端会一直等待请求的响应，这非常影响用户体验。对于一个优秀的网站而言，良好的用户体验十分重要，这也说明了一个支持异步功能的第三方插件的重要性。为了能让 Django 搭建的 Web 系统支持这样的异步功能，于是 django-celery 便应运而生。django-celery项目之后也被移到 celery 下进行统一管理。 django-celery是django web开发中执行异步任务或定时任务的最佳选择。它的应用场景包括: * 异步任务: 当用户触发一个动作需要较长时间来执行完成时，可以把它作为任务交给celery异步执行，执行完再返回给用户。这点和在前端使用ajax实现异步加载有异曲同工之妙。 * 定时任务。假设有多台服务器，多个任务，定时任务的管理是很困难的，要在不同电脑上写不同的crontab，而且还不好管理。Celery可以帮助快速在不同的机器设定不同任务。 * 其他可以异步执行的任务。比如发送短信，邮件，推送消息，清理/设置缓存等。这点还是比较有用的。 Django-constance - 常量管理 官网地址：https://django-constance.readthedocs.io/en/latest/ 有时会在 django 的 settings 中设置一些常量，但是有可能会进行变更。利用这个包，只需简单的配置就可以自动生成 admin 管理后台可以修改管理常量。 Django-filter - 过滤数据使用 官网地址：https://django-filter.readthedocs.io/en/latest/ Django-filter允许用户模型字段进一步过滤从数据库查得到的queryset，从而筛选显示用户想要的查询结果，这样避免了对数据库的再次查询，大大提升了效率。比如用户访问文章列表页面，已经看到了文章清单，但用户还希望通过标题关键词进一步在查询结果中筛选出自己感兴趣的文章清单(而不必重新查询数据库)，这时使用Django-filter就可以轻松帮实现上述需求。 Django-guardian 官网地址：https://django-guardian.readthedocs.io/en/stable/index.html 在介绍Django权限管理时，提到过Django没有提供对象（Object）级别的权限控制。一个用户如果对Article模型有修改的权限，那么他将对所有Article对象有修改权限。使用django-guardian可以帮助实现对对象级别（比如某篇具体文章）的权限控制。 Django-activity-stream 官网地址：https://github.com/justquick/django-activity-stream Django-activity-stream是一个Django应用程序，用于记录和显示活动流，例如用户活动、社交事件和系统通知。它可以帮助开发人员更好地跟踪和展示应用程序中的活动。 如果要开发一个社交类网站，需要实现用户关注、收藏、点赞、用户动态等功能时，这个第三方库可以快速帮实现并提供用户的活动流。出于学习目的话，该项目的源码也是一个很好的学习对象。 Django-pure-pagination 官网地址：https://github.com/jamespacileo/django-pure-pagination Django虽然自带强大分页给功能，但当页数非常多时显示结果对用户并不友好。比如有1000页，那么1到1000每个数字都会出现页面上。使用django-pure-pagination则可以快速实现如下按范围展示的完美分页方式，值得一试。 Django-rules 官网地址：https://github.com/dfunckt/django-rules Django-rules是一个Django应用程序，用于定义简单的规则系统，在运行时根据这些规则授权、限制或过滤用户行为。它可以帮助开发人员更轻松地实现复杂的授权和权限管理。 一个小巧但是强大的应用，提供对象级别的权限管理，且不需要使用数据库。 django-import-export 官网地址：h","date":"2021-06-18","objectID":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:20:0","tags":null,"title":"基于Vue.js+Django的web项目 Django项目创建","uri":"/%E5%9F%BA%E4%BA%8Evue.js-django%E7%9A%84web%E9%A1%B9%E7%9B%AE-django%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"1，数据分析要点 -目的需求，明确分析逻辑 -数据处理分析 -数据可视化展示 ","date":"2019-12-18","objectID":"/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:1:0","tags":null,"title":"Python数据分析","uri":"/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2，相关介绍 ","date":"2019-12-18","objectID":"/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:2:0","tags":null,"title":"Python数据分析","uri":"/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":null,"content":"1、方法论，分析的逻辑 1.1 PEST分析法 PEST分析是指宏观环境的分析，宏观环境是指影响一切行业或企业的各种宏观力量。P是政治(Politics)，E是经济(Economy)，S是社会(Society)，T是技术(Technology)。通常是战略咨询顾问用来帮助企业检阅其外部宏观环境的一种方法 1.2 5W2H分析法 5W2H分析法又称七何分析法，包括：Why、What、Where、When、Who、How、How much 。主要用于用户行为分析、业务问题专题分析、营销活动等，是一个方便又实用的工具。 1.3 逻辑树分析法 逻辑树是分析问题最常用的工具之一，它是将问题的所有子问题分层罗列，从最高层开始，并逐步向下扩展。使用逻辑树分析的主要优点是保证解决问题的过程的完整性，且方便将工作细分为便于操作的任务，确定各部分的优先顺序，明确地把责任落实到个人。 1.4 4P营销理论 4P即产品（Product）、价格（Price）、渠道（Place）、促销（Promotion），在营销领域，这种以市场为导向的营销组合理论，被企业应用最普遍。通过将四者的结合、协调发展，从而提高企业的市场份额，达到最终获利的目的。 4P营销理论适用于分析企业的经营状况，可视为企业内部环境，PEST分析的是企业在外部面对的环境。 1.5 SCQA分析法 SCQA分析是一个“结构化表达”工具，即S（Situation）情景、C（Complication）冲突、Q（Question）疑问、A（Answer）回答。 整个结构是通过描述当事者的现实状态，然后带出冲突和核心问题，通过结构化分析以提供更为明智的解决方案。 1. 6SMART分析法 SMART法是一种目标管理方法，即对目标的S（Specific）明确性，M（Measurable）可衡量性，A（Attainable）可实现性，R（Relevant）相关性，T（Time-based）时限性。 1.7 SWOT分析法 SWOT分析法也叫态势分析法，S （Strengths）是优势、W （Weaknesses）是劣势，O （Opportunities）是机会、T （Threats）是威胁或风险。常用来确定企业自身的内部优势、劣势和外部的机会和威胁等，从而将公司的战略与公司内部与外部环境有机地结合起来。 ","date":"2019-12-18","objectID":"/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:2:1","tags":null,"title":"Python数据分析","uri":"/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":null,"content":"2、数据处理分析 2.1数据清洗 是指对数据进行预处理，包括去除重复值、缺失值、异常值等，以提高数据的质量 2.2数据分析 数据分析的技术方法是指提取出关键指标信息的具体方法，如对比分析、交叉分析、回归预测分析等方法。包括统计分析、机器学习等，以发现数据中的规律和趋势 ","date":"2019-12-18","objectID":"/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:2:2","tags":null,"title":"Python数据分析","uri":"/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":null,"content":"3、数据可视化 数据可视化是指将数据以图表等形式展示出来，以便更好地理解和分析数据。 ","date":"2019-12-18","objectID":"/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:2:3","tags":null,"title":"Python数据分析","uri":"/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"categories":null,"content":"3，常用库 Python数据分析中常用的库和框架有很多，以下是一些常见的： 数据挖掘：NumPy、SciPy、Matplotlib、Pandas、ScikitLearn、Keras、Gensim等 。 数据清洗：Pandas、NumPy等。 数据分析：Pandas、NumPy等。 数据可视化：Matplotlib、Seaborn、Plotly、powerbi、ECharts ","date":"2019-12-18","objectID":"/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/:3:0","tags":null,"title":"Python数据分析","uri":"/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]